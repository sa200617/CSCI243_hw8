#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>


typedef struct{
	size_t size;
	int *data;
}qs_args_t;

int count = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void partition_array(int pivot, const int *data, size_t size,
			int **less, size_t *lessS, int **equal,
			size_t *equalS, int **greater, size_t *greaterS){

	*lessS = 0;
	*equalS = 0;
	*greaterS = 0;

	for (size_t num = 0; num < size; num++){
		if (data[num] < pivot){(*lessS)++;}
		else if (data[num] > pivot){(*greaterS)++;}
		else{(*equalS)++;}
	}
	*less = malloc(*lessS * sizeof(int));
	*equal = malloc(*equalS *sizeof(int));
	*greater = malloc(*greaterS *sizeof(int));


	size_t lessL = 0;
	size_t equalL =  0;
	size_t greaterL = 0;

	for (size_t num = 0; num < size; num++){
		if(data[num] < pivot){
			(*less)[lessL++] = data[num];
		}
		else if (data[num] > pivot){
			(*greater)[greaterL++] = data[num];
		}
		else{
			(*equal)[equalL++] = data[num];
		}
	}

}


int *merge(int *less, size_t lessS, int *equal, size_t equalS,
		int *greater, size_t greaterS){

		size_t sizeL = lessS + equalS + greaterS;
		int *list = malloc(sizeL * sizeof(int));

		size_t pos = 0;

		for (size_t num = 0; num < lessS; num++){
			list[pos++] = less[num];
		}
		for (size_t num = 0; num < equalS; num++){
			list[pos++] = equal[num];
		}
		for (size_t num = 0; num < greaterS; num++){
			list[pos++] = greater[num];
		}

		free(less);
		free(equal);
		free(greater);

		return list;
}

int *quicksort(size_t size, const int *data){

	if (size == 0){
		return malloc(0);
	}

	int pivot = data[0];

	int *less, *equal, *greater;
	size_t lessS, equalS, greaterS;
	partition_array(pivot, data, size,&less, &lessS,
			&equal, &equalS, &greater, &greaterS);

	int *sortedLess = quicksort(lessS, less);
	int *sortedGreater = quicksort(greaterS, greater);

	free(less);
	free(greater);

	int *res = malloc((lessS + greaterS + equalS) * sizeof(int));

	size_t pos = 0;
	for (size_t num = 0; num < lessS; num++){
		res[pos++] = sortedLess[num];
	}
	for (size_t num = 0; num < equalS; num++){
		res[pos++] = equal[num];
	}
	for (size_t num = 0; num < greaterS; num++){
		res[pos++] = sortedGreater[num];
	}

	free(equal);
	free(sortedLess);
	free(sortedGreater);

	return res;
}

void *quicksort_threaded(void *args){

	qs_args_t *arg = args;

	if (args->size == 0){
		int *empty = malloc(0);
		free(args);
		return empty;
	}

	int pivot = args-> data[0];

	int *less;
	int *equal;
	int *greater;

	size_t lessS;
	size_t equalS;
	size_t greaterS;

	partition_array(pivot, args->data, args->size,
                    &less, &lessS,
                    &equal, &equalS,
                    &greater, &greaterS);

	pthread_t thread1, thread2;

	qs_args_t *arg1 = NULL;
	qs_args_t *ag2 = NULL;
	int *sortedLess = NULL;
	int *sortedGreater = NULL;

	if (lessS > 0){
		pthread_mutex_lock(&lock);
		count ++;
		pthread_mutex_unlock(&lock);

		arg1 = malloc(sizeof(qs_args_t));
		arg1->size = lessS;
		arg1-> data = less;

		pthread_create(&thread1, quicksort_threaded, arg1);

	}

	 if (greaterS > 0){
                pthread_mutex_lock(&lock);
                count ++;
                pthread_mutex_unlock(&lock);

                arg2 = malloc(sizeof(qs_args_t));
                arg2->size = greaterS;
                arg2-> data = greater;

                pthread_create(&thread2, quicksort_threaded, arg2);

        }

	if (lessS > 0){
		pthread_join(thread1, (void**)&sortedLess);
	else{
		sortedLess = malloc(0);
		free(less);
	}

	if (greaterS > 0){
                pthread_join(thread2, (void**)&sortedGreater);
        else{
                sortedGreater = malloc(0);
                free(greater);
        }
	#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>

typedef struct {
    size_t size;
    int *data;
} qs_args_t;

/* GLOBAL THREAD COUNTER */
int thread_count = 0;
pthread_mutex_t lock = PTHREAD_MUTE
/* ====================== PARTITION FUNCTION ====================== */
void partition_array(int pivot, const int *data, size_t size,
                     int **less, size_t *less_size,
                     int **equal, size_t *equal_size,
                     int **greater, size_t *greater_size)
{
    *less_size = *equal_size = *greater_size = 0;

    /* First count sizes */
    for(size_t i = 0; i < size; i++) {
        if(data[i] < pivot) (*less_size)++;
        else if(data[i] > pivot) (*greater_size)++;
        else (*equal_size)++;
    }

    /* Allocate arrays */
    *less = malloc(*less_size * sizeof(int));
    *equal = malloc(*equal_size * sizeof(int));
    *greater = malloc(*greater_size * sizeof(int));

    size_t li = 0, ei = 0, gi = 0;

    for(size_t i = 0; i < size; i++) {
        if(data[i] < pivot)       (*less)[li++] = data[i];
        else if(data[i] > pivot)  (*greater)[gi++] = data[i];
        else                       (*equal)[ei++] = data[i];
    }
}

/* ====================== MERGE FUNCTION ====================== */
int *merge_arrays(int *less, size_t ls,
                  int *equal, size_t es,
                  int *greater, size_t gs)
{
    size_t total = ls + es + gs;
    int *result = malloc(total * sizeof(int));

    size_t pos = 0;

    /* Copy less */
    for(size_t i = 0; i < ls; i++) result[pos++] = less[i];
    /* Copy equal */
    for(size_t i = 0; i < es; i++) result[pos++] = equal[i];
    /* Copy greater */
    for(size_t i = 0; i < gs; i++) result[pos++] = greater[i];

    free(less);
    free(equal);
    free(greater);

    return result;
}

/* ====================== NON-THREADED QUICKSORT ====================== */

int *quicksort(size_t size, const int *data) {
    if(size == 0) return malloc(0);

    int pivot = data[0];

    int *less, *equal, *greater;
    size_t ls, es, gs;

    partition_array(pivot, data, size,
                    &less, &ls,
                    &equal, &es,
                    &greater, &gs);

    int *sorted_less = quicksort(ls, less);
    int *sorted_greater = quicksort(gs, greater);

    free(less);
    free(greater);

    int *result = malloc((ls + es + gs) * sizeof(int));

    size_t pos = 0;
    for(size_t i = 0; i < ls; i++) result[pos++] = sorted_less[i];
    for(size_t i = 0; i < es; i++) result[pos++] = equal[i];
    for(size_t i = 0; i < gs; i++) result[pos++] = sorted_greater[i];

    free(equal);
    free(sorted_less);
    free(sorted_greater);

    return result;
}

/* ====================== THREADED QUICKSORT ====================== */

void *quicksort_threaded(v
